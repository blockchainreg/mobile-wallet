// Generated by LiveScript 1.5.0
(function(){
  var ref$, objToPairs, map, pairsToObj, each, find, keys, guid, waitFormResult, changeAmount, div, plus, times, protect, navigate, useNetwork, getBalance, buildInstall, buildUninstall, buildInstallByName, buildQuickInstall, backgroundRefreshAccount, setAccount, Web3, ethnamed, getRecord, setPageTheme, mirror, getCoins, state, titles, showCases, buildGetBalance, buildUnlock, buildSendTransaction, getContractInstance, buildContract, buildNetworkEthereum, buildOtherNetworks, buildNetworkSpecific, buildGetUsdAmount, buildApi, buildUse, getApis, refreshApis, setupRefreshTimer, buildGetAccountName, buildGetSupportedTokens, buildGetAddress, slice$ = [].slice, toString$ = {}.toString;
  ref$ = require('prelude-ls'), objToPairs = ref$.objToPairs, map = ref$.map, pairsToObj = ref$.pairsToObj, each = ref$.each, find = ref$.find, keys = ref$.keys;
  guid = require('./guid.js');
  waitFormResult = require('./send-form.js').waitFormResult;
  changeAmount = require('./calc-amount.js').changeAmount;
  ref$ = require('./math.js'), div = ref$.div, plus = ref$.plus, times = ref$.times;
  navigate = ()=> {}
  useNetwork = require('./use-network.js');
  getBalance = require('./api.js').getBalance;
  ref$ = require('./install-plugin.js'), buildInstall = ref$.buildInstall, buildUninstall = ref$.buildUninstall, buildInstallByName = ref$.buildInstallByName, buildQuickInstall = ref$.buildQuickInstall;
  ref$ = require('./refresh-account.js'), backgroundRefreshAccount = ref$.backgroundRefreshAccount, setAccount = ref$.setAccount;
  //Web3 = require('web3');
  ethnamed = require('../api/ethnamed.js');
  getRecord = require('./get-record.js');
  setPageTheme = require('./set-page-theme.js');
  mirror = require('./mirror.js');
  getCoins = require('./plugin-loader.js').getCoins;
  state = {
    time: null
  };
  titles = ['name@email.com', 'name.ethnamed.io', 'domain.com'];
  showCases = function(store, arg$, cb){
    var title, titles;
    title = arg$[0], titles = slice$.call(arg$, 1);
    if (title == null) {
      return cb(null);
    }
    store.current.sendToMask = title;
    return setTimeout(function(){
      return showCases(store, titles, function(){
        return cb(null);
      });
    }, 1000);
  };
  buildGetBalance = function(store, coin){
    return function(cb){
      var network, wallet;
      network = coin[store.current.network];
      wallet = coin.wallet;
      return getBalance({
        token: coin.token,
        network: network,
        address: wallet.address
      }, cb);
    };
  };
  buildUnlock = function(store, cweb3){
    return function(cb){
      if (store.page === 'locked') {
        return cb(null);
      }
      return waitFormResult('unlock', function(err, data){
        if (err != null) {
          return cb(err);
        }
        return cb(null, data);
      });
    };
  };
  buildSendTransaction = function(store, cweb3, coin){
    return function(tx, cb){
      var network, to, data, decodedData, value, gas, amount, ref$, id, current, send, amountObtain, amountObtainUsd, amountSendUsd, amountSendFee, amountSendFeeUsd, proposeEscrow, amountSend, wallet, helps, this$ = this;
      network = coin[store.current.network];
      if (toString$.call(tx).slice(8, -1) !== 'Object') {
        return cb("Transaction is required");
      }
      to = tx.to, data = tx.data, decodedData = tx.decodedData, value = tx.value, gas = tx.gas, amount = tx.amount;
      if (toString$.call(tx.to).slice(8, -1) !== 'String') {
        return cb("Recipient (to) is required");
      }
      value = (function(){
        switch (false) {
        case value == null:
          return value;
        case amount == null:
          return times(amount, Math.pow(10, network.decimals));
        default:
          return null;
        }
      }());
      if ((ref$ = toString$.call(value).slice(8, -1)) !== 'String' && ref$ !== 'Number') {
        return cb("Either Value or Amount is required");
      }
      id = guid();
      current = store.current;
      send = current.send;
      amountObtain = '0';
      amountObtainUsd = '0';
      amountSendUsd = '0';
      amountSendFee = '0';
      amountSendFeeUsd = '0';
      proposeEscrow = false;
      amountSend = div(value, Math.pow(10, network.decimals));
      wallet = find(function(it){
        return it.coin.token === coin.token;
      })(
      store.current.account.wallets);
      importAll$(send, {
        to: to,
        data: data,
        decodedData: decodedData,
        network: network,
        coin: coin,
        wallet: wallet,
        value: value,
        gas: gas,
        id: id,
        amountSend: amountSend,
        amountObtain: amountObtain,
        amountObtainUsd: amountObtainUsd,
        amountSendUsd: amountSendUsd,
        amountSendFee: amountSendFee,
        amountSendFeeUsd: amountSendFeeUsd,
        proposeEscrow: proposeEscrow
      });
      changeAmount(store, amountSend);
      navigate(store, cweb3, 'send');
      helps = titles.concat([network.mask]);
      showCases(store, helps, function(){});
      return waitFormResult(id, function(err, data){
        if (err != null) {
          return cb(err);
        }
        return cb(null, data);
      });
    };
  };
  getContractInstance = function(web3, abi, addr){
    switch (false) {
    case toString$.call(web3.eth.contract).slice(8, -1) !== 'Function':
      return web3.eth.contract(abi).at(addr);
    default:
      return new web3.eth.Contract(abi, addr);
    }
  };
  buildContract = function(store, methods, coin){
    return function(abi){
      return {
        at: function(address){
          var sendTransaction, network, web3;
          sendTransaction = methods.sendTransaction;
          network = coin[store.current.network];
          web3 = new Web3();
          web3.setProvider(new web3.providers.HttpProvider(network.api.web3Provider));
          web3.eth.sendTransaction = function(arg$, cb){
            var value, data, to;
            value = arg$.value, data = arg$.data, to = arg$.to;
            return sendTransaction({
              to: to,
              data: data,
              value: value
            }, cb);
          };
          return getContractInstance(web3, abi, address);
        }
      };
    };
  };
  buildNetworkEthereum = function(store, methods, coin){
    var sendTransaction, getBalance, getAddress, contract;
    sendTransaction = methods.sendTransaction, getBalance = methods.getBalance, getAddress = methods.getAddress;
    contract = buildContract(store, methods, coin);
    return {
      sendTransaction: sendTransaction,
      getBalance: getBalance,
      getAddress: getAddress,
      contract: contract
    };
  };
  buildOtherNetworks = function(store, methods, coin){
    var sendTransaction, getBalance, getAddress, contract;
    sendTransaction = methods.sendTransaction, getBalance = methods.getBalance, getAddress = methods.getAddress;
    contract = function(){
      throw "Not Implemented For this network";
    };
    return {
      sendTransaction: sendTransaction,
      getBalance: getBalance,
      getAddress: getAddress,
      contract: contract
    };
  };
  buildNetworkSpecific = function(store, methods, coin){
    var builder;
    builder = (function(){
      switch (false) {
      //case !in$(coin.token, ['eth']):
      //  return buildNetworkEthereum;
      default:
        return buildOtherNetworks;
      }
    }());
    return builder(store, methods, coin);
  };
  buildGetUsdAmount = function(store, coin){
    return function(amount, cb){
      var ref$, wallet, usd, this$ = this;
      if (toString$.call((ref$ = store.current.account) != null ? ref$.wallets : void 8).slice(8, -1) !== 'Array') {
        return cb("wallet isnt loaded");
      }
      wallet = find(function(it){
        return it.coin.token === coin.token;
      })(
      store.current.account.wallets);
      if (wallet == null) {
        return cb("wallet not found for " + token);
      }
      if (wallet.usdRate == null) {
        return cb("usd rate not found " + token);
      }
      usd = times(amount, wallet.usdRate);
      return cb(null, usd);
    };
  };
  buildApi = function(store, cweb3, coin){
    var sendTransaction, getBalance, getAddress, getUsdAmount, methods;
    sendTransaction = buildSendTransaction(store, cweb3, coin);
    getBalance = buildGetBalance(store, coin);
    getAddress = buildGetAddress(store, coin);
    getUsdAmount = buildGetUsdAmount(store, coin);
    methods = {
      getAddress: getAddress,
      sendTransaction: sendTransaction,
      getBalance: getBalance,
      getUsdAmount: getUsdAmount
    };
    return buildNetworkSpecific(store, methods, coin);
  };
  buildUse = function(web3, store){
    return function(network){
      return useNetwork(web3, store, network, function(){});
    };
  };
  getApis = function(cweb3, store, cb){
    var res;
    res = pairsToObj(
    map(function(it){
      return [it.token, buildApi(store, cweb3, it)];
    })(
    store.coins));
    return cb(null, res);
  };
  refreshApis = function(cweb3, store, cb){
    var this$ = this;
    each(function(it){
      var ref$;
      return ref$ = cweb3[it], delete cweb3[it], ref$;
    })(
    map(function(it){
      return it.token;
    })(
    store.coins));
    return getCoins(function(err, coins){
      if (err != null) {
        return cb(err);
      }
      store.coins = coins;
      return getApis(cweb3, store, function(err, apis){
        if (err != null) {
          return cb(err);
        }
        importAll$(cweb3, apis);
        return cb(null);
      });
    });
  };
  setupRefreshTimer = function(arg$){
    var refreshTimer, refreshBalances;
    refreshTimer = arg$.refreshTimer, refreshBalances = arg$.refreshBalances;
    if (toString$.call(refreshTimer).slice(8, -1) !== 'Number') {
      return;
    }
    clearTimeout(setupRefreshTimer.timer);
    return setupRefreshTimer.timer = setTimeout(refreshBalances, refreshTimer);
  };
  buildGetAccountName = function(cweb3, naming){
    return function(store, cb){
      var record;
      record = getRecord(store);
      return naming.whois(record, function(err, data){
        if (err != null) {
          return cb(err);
        }
        return cb(null, data);
      });
    };
  };
  buildGetSupportedTokens = function(cweb3, store){
    return function(cb){
      var ref$, tokens, this$ = this;
      if (toString$.call((ref$ = store.current.account) != null ? ref$.wallets : void 8).slice(8, -1) !== 'Array') {
        return cb("wallet isnt loaded");
      }
      tokens = map(function(it){
        return it.token;
      })(
      store.coins);
      return cb(null, tokens);
    };
  };
  buildGetAddress = function(store, coin){
    return function(cb){
      var address;
      if (mirror.accountAddresses == null) {
        return cb("wallet isnt loaded");
      }
      address = mirror.accountAddresses[coin.token];
      if (address == null) {
        return cb("wallet not found for " + coin.token);
      }
      return cb(null, address);
    };
  };
  module.exports = function(store, config){
    var cweb3, refreshTimer, use, install, installQuick, uninstall, installByName, naming, getSupportedTokens, getAccountName, refreshBalances, init, refreshInterface, refresh, setTheme, setLang, setPreference, lock, unlock, web3;
    cweb3 = {};
    refreshTimer = config != null ? config.refreshTimer : void 8;
    use = buildUse(cweb3, store);
    install = buildInstall(cweb3, store);
    installQuick = buildQuickInstall(cweb3, store);
    uninstall = buildUninstall(cweb3, store);
    installByName = buildInstallByName(cweb3, store);
    naming = ethnamed(cweb3);
    getSupportedTokens = buildGetSupportedTokens(cweb3, store);
    getAccountName = buildGetAccountName(cweb3, naming);
    refreshBalances = function(cb){
      setupRefreshTimer({
        refreshTimer: refreshTimer,
        refreshBalances: refreshBalances
      });
      return backgroundRefreshAccount(cweb3, store, function(err){
        return typeof cb == 'function' ? cb(null) : void 8;
      });
    };
    setupRefreshTimer({
      refreshTimer: refreshTimer,
      refreshBalances: refreshBalances
    });
    init = function(cb){
      return setAccount(cweb3, store, cb);
    };
    refreshInterface = function(cb){
      return refreshApis(cweb3, store, function(err){
        if (err != null) {
          return cb(err);
        }
        return cb(null);
      });
    };
    refresh = function(cb){
      return refreshInterface(function(err){
        if (err != null) {
          return cb(err);
        }
        return refreshBalances(cb);
      });
    };
    setTheme = function(it, cb){
      if (it !== 'dark' && it !== 'light' && it !== 'monochrome' && it !== 'dark_mojave') {
        return cb("support only dark an light");
      }
      store.theme = it;
      setPageTheme(store, it);
      return cb(null);
    };
    setLang = function(it, cb){
      if (it !== 'en' && it !== 'ru' && it !== 'ua') {
        return cb("support only en, ru");
      }
      store.lang = it;
      return cb(null);
    };
    setPreference = function(preference){
      var set;
      set = function(key){
        var ref$;
        return store.preference[key] = (ref$ = preference[key]) != null
          ? ref$
          : store.preference[key];
      };
      return each(set)(
      keys(
      store.preference));
    };
    lock = function(){
      return navigate(store, void 8, 'locked');
    };
    unlock = buildUnlock(store, cweb3);
    refreshInterface(function(){});
    //web3 = new Web3();
    importAll$(cweb3, {
      unlock: unlock,
      setPreference: setPreference,
      getSupportedTokens: getSupportedTokens,
      use: use,
      refresh: refresh,
      lock: lock,
      init: init,
      install: install,
      uninstall: uninstall,
      installByName: installByName,
      naming: naming,
      getAccountName: getAccountName,
      setTheme: setTheme,
      setLang: setLang,
      installQuick: installQuick
    });
    return cweb3;
  };
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
