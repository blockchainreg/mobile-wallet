import commonProvider from '../web3t/providers/common/provider';

// Generated by LiveScript 1.5.0
(function () {
  var ref$,
    objToPairs,
    map,
    pairsToObj,
    each,
    find,
    keys,
    guid,
    waitFormResult,
    changeAmount,
    div,
    plus,
    times,
    protect,
    navigate,
    useNetwork,
    getBalance,
    buildInstall,
    buildUninstall,
    buildInstallByName,
    buildQuickInstall,
    backgroundRefreshAccount,
    setAccount,
    Web3,
    ethnamed,
    getRecord,
    setPageTheme,
    mirror,
    getCoins,
    state,
    titles,
    showCases,
    buildGetBalance,
    buildUnlock,
    buildSendTransaction,
    buildContract,
    buildNetworkEthereum,
    buildOtherNetworks,
    buildNetworkSpecific,
    buildGetUsdAmount,
    buildApi,
    buildUse,
    getApis,
    refreshApis,
    setupRefreshTimer,
    buildGetAccountName,
    buildGetSupportedTokens,
    buildGetAddress,
    slice$ = [].slice,
    toString$ = {}.toString;
  (ref$ = require('prelude-ls')),
    (objToPairs = ref$.objToPairs),
    (map = ref$.map),
    (pairsToObj = ref$.pairsToObj),
    (each = ref$.each),
    (find = ref$.find),
    (keys = ref$.keys);
  guid = require('./guid.js');
  const velasApi = require('./velas/velas-api');
  waitFormResult = require('./send-form.js').waitFormResult;
  changeAmount = require('./calc-amount.js').changeAmount;
  (ref$ = require('./math.js')),
    (div = ref$.div),
    (plus = ref$.plus),
    (times = ref$.times);
  navigate = () => {};
  useNetwork = require('./use-network.js');
  getBalance = require('./api.js').getBalance;
  (ref$ = require('./install-plugin.js')),
    (buildInstall = ref$.buildInstall),
    (buildUninstall = ref$.buildUninstall),
    (buildInstallByName = ref$.buildInstallByName),
    (buildQuickInstall = ref$.buildQuickInstall);
  (ref$ = require('./refresh-account.js')),
    (backgroundRefreshAccount = ref$.backgroundRefreshAccount),
    (setAccount = ref$.setAccount);
  ethnamed = require('../api/ethnamed.js');
  getRecord = require('./get-record.js');
  setPageTheme = require('./set-page-theme.js');
  mirror = require('./mirror.js');
  getCoins = require('./plugin-loader.js').getCoins;
  state = {
    time: null,
  };
  titles = ['name@email.com', 'name.ethnamed.io', 'domain.com'];
  showCases = function (store, arg$, cb) {
    var title, titles;
    (title = arg$[0]), (titles = slice$.call(arg$, 1));
    if (title == null) {
      return cb(null);
    }
    store.current.sendToMask = title;
    return setTimeout(function () {
      return showCases(store, titles, function () {
        return cb(null);
      });
    }, 1000);
  };
  buildGetBalance = function (store, coin) {
    return function (cb) {
      var network, wallet;
      network = coin[store.current.network];
      wallet = coin.wallet;
      return getBalance(
        {
          token: coin.token,
          network: network,
          address: wallet.address,
        },
        cb
      );
    };
  };
  buildUnlock = function (store, cweb3) {
    return function (cb) {
      if (store.page === 'locked') {
        return cb(null);
      }
      return waitFormResult('unlock', function (err, data) {
        if (err != null) {
          return cb(err);
        }
        return cb(null, data);
      });
    };
  };
  buildSendTransaction = function (store, cweb3, coin) {
    return function (tx, cb) {
      var network,
        to,
        data,
        decodedData,
        value,
        gas,
        amount,
        ref$,
        id,
        current,
        send,
        amountObtain,
        amountObtainUsd,
        amountSendUsd,
        amountSendFee,
        amountSendFeeUsd,
        proposeEscrow,
        amountSend,
        wallet,
        helps,
        this$ = this;
      network = coin[store.current.network];
      if (toString$.call(tx).slice(8, -1) !== 'Object') {
        return cb('Transaction is required');
      }
      (to = tx.to),
        (data = tx.data),
        (decodedData = tx.decodedData),
        (value = tx.value),
        (gas = tx.gas),
        (amount = tx.amount);
      if (toString$.call(tx.to).slice(8, -1) !== 'String') {
        return cb('Recipient (to) is required');
      }
      value = (function () {
        switch (false) {
          case value == null:
            return value;
          case amount == null:
            return times(amount, Math.pow(10, network.decimals));
          default:
            return null;
        }
      })();
      if (
        (ref$ = toString$.call(value).slice(8, -1)) !== 'String' &&
        ref$ !== 'Number'
      ) {
        return cb('Either Value or Amount is required');
      }
      id = guid();
      current = store.current;
      send = current.send;
      amountObtain = '0';
      amountObtainUsd = '0';
      amountSendUsd = '0';
      amountSendFee = '0';
      amountSendFeeUsd = '0';
      proposeEscrow = false;
      amountSend = div(value, Math.pow(10, network.decimals));
      wallet = find(function (it) {
        return it.coin.token === coin.token;
      })(store.current.account.wallets);
      importAll$(send, {
        to: to,
        data: data,
        decodedData: decodedData,
        network: network,
        coin: coin,
        wallet: wallet,
        value: value,
        gas: gas,
        id: id,
        amountSend: amountSend,
        amountObtain: amountObtain,
        amountObtainUsd: amountObtainUsd,
        amountSendUsd: amountSendUsd,
        amountSendFee: amountSendFee,
        amountSendFeeUsd: amountSendFeeUsd,
        proposeEscrow: proposeEscrow,
      });
      changeAmount(store, amountSend, true, (err, res) => {
        navigate(store, cweb3, 'send');
        helps = titles.concat([network.mask]);
        showCases(store, helps, function () {});
        return waitFormResult(id, function (err, data) {
          if (err != null) {
            return cb(err);
          }
          return cb(null, data);
        });
      });
    };
  };
  buildContract = function (store, methods, coin) {
    return function (abi) {
      return {
        at: function (address) {
          var sendTransaction, network, web3;
          sendTransaction = methods.sendTransaction;
          network = coin[store.current.network];
          web3 = new Web3();
          web3.setProvider(
            new web3.providers.HttpProvider(network.api.web3Provider)
          );
          web3.eth.sendTransaction = function (arg$, cb) {
            var value, data, to;
            (value = arg$.value), (data = arg$.data), (to = arg$.to);
            return sendTransaction(
              {
                to: to,
                data: data,
                value: value,
              },
              cb
            );
          };
          const getContractInstance =
            commonProvider.getContractInstanceWithAbi(abi);
          return getContractInstance(web3, abi, address);
        },
      };
    };
  };
  buildNetworkEthereum = function (store, methods, coin) {
    var sendTransaction, getBalance, getAddress, contract;
    (sendTransaction = methods.sendTransaction),
      (getBalance = methods.getBalance),
      (getAddress = methods.getAddress);
    contract = buildContract(store, methods, coin);
    return {
      sendTransaction: sendTransaction,
      getBalance: getBalance,
      getAddress: getAddress,
      contract: contract,
    };
  };
  buildOtherNetworks = function (store, methods, coin) {
    var sendTransaction, getBalance, getAddress, contract;
    (sendTransaction = methods.sendTransaction),
      (getBalance = methods.getBalance),
      (getAddress = methods.getAddress);
    contract = function () {
      throw 'Not Implemented For this network';
    };
    return {
      sendTransaction: sendTransaction,
      getBalance: getBalance,
      getAddress: getAddress,
      contract: contract,
    };
  };
  buildNetworkSpecific = function (store, methods, coin) {
    var builder;
    builder = (function () {
      switch (false) {
        //case !in$(coin.token, ['eth']):
        //  return buildNetworkEthereum;
        default:
          return buildOtherNetworks;
      }
    })();
    return builder(store, methods, coin);
  };
  buildGetUsdAmount = function (store, coin) {
    return function (amount, cb) {
      var ref$,
        wallet,
        usd,
        this$ = this;
      if (
        toString$
          .call((ref$ = store.current.account) != null ? ref$.wallets : void 8)
          .slice(8, -1) !== 'Array'
      ) {
        return cb('wallet isnt loaded');
      }
      wallet = find(function (it) {
        return it.coin.token === coin.token;
      })(store.current.account.wallets);
      if (wallet == null) {
        return cb('wallet not found for ' + token);
      }
      if (wallet.usdRate == null) {
        return cb('usd rate not found ' + token);
      }
      usd = times(amount, wallet.usdRate);
      return cb(null, usd);
    };
  };
  buildApi = function (store, cweb3, coin) {
    var sendTransaction, getBalance, getAddress, getUsdAmount, methods;
    sendTransaction = buildSendTransaction(store, cweb3, coin);
    getBalance = buildGetBalance(store, coin);
    getAddress = buildGetAddress(store, coin);
    getUsdAmount = buildGetUsdAmount(store, coin);
    methods = {
      getAddress: getAddress,
      sendTransaction: sendTransaction,
      getBalance: getBalance,
      getUsdAmount: getUsdAmount,
    };
    return buildNetworkSpecific(store, methods, coin);
  };
  buildUse = function (web3, store) {
    return function (network) {
      return useNetwork(web3, store, network, function () {});
    };
  };
  getApis = function (cweb3, store, cb) {
    var res;
    res = pairsToObj(
      map(function (it) {
        return [it.token, buildApi(store, cweb3, it)];
      })(store.coins)
    );
    return cb(null, res);
  };
  refreshApis = function (cweb3, store, cb) {
    var this$ = this;
    each(function (it) {
      var ref$;
      return (ref$ = cweb3[it]), delete cweb3[it], ref$;
    })(
      map(function (it) {
        return it.token;
      })(store.coins)
    );
    cweb3.velas = velasApi(store);
    return getCoins(store, function (err, coins) {
      if (err != null) {
        return cb(err);
      }
      store.coins = coins;
      return getApis(cweb3, store, function (err, apis) {
        store.current.send.sending = false;
        if (err != null) {
          return cb(err);
        }
        importAll$(cweb3, apis);
        return cb(null);
      });
    });
  };
  setupRefreshTimer = function (arg$) {
    var refreshTimer, refreshBalances;
    (refreshTimer = arg$.refreshTimer),
      (refreshBalances = arg$.refreshBalances);
    if (toString$.call(refreshTimer).slice(8, -1) !== 'Number') {
      return;
    }
    clearTimeout(setupRefreshTimer.timer);
    return (setupRefreshTimer.timer = setTimeout(
      refreshBalances,
      refreshTimer
    ));
  };
  buildGetAccountName = function (cweb3, naming) {
    return function (store, cb) {
      var record;
      record = getRecord(store);
      return naming.whois(record, function (err, data) {
        if (err != null) {
          return cb(err);
        }
        return cb(null, data);
      });
    };
  };
  buildGetSupportedTokens = function (cweb3, store) {
    return function (cb) {
      var ref$,
        tokens,
        this$ = this;
      if (
        toString$
          .call((ref$ = store.current.account) != null ? ref$.wallets : void 8)
          .slice(8, -1) !== 'Array'
      ) {
        return cb('wallet isnt loaded');
      }
      tokens = map(function (it) {
        return it.token;
      })(store.coins);
      return cb(null, tokens);
    };
  };
  buildGetAddress = function (store, coin) {
    return function (cb) {
      var address;
      if (mirror.accountAddresses == null) {
        return cb('wallet isnt loaded');
      }
      address = mirror.accountAddresses[coin.token];
      if (address == null) {
        return cb('wallet not found for ' + coin.token);
      }
      return cb(null, address);
    };
  };
  module.exports = function (store, config) {
    var cweb3,
      refreshTimer,
      use,
      install,
      installQuick,
      uninstall,
      installByName,
      naming,
      getSupportedTokens,
      getAccountName,
      refreshBalances,
      init,
      refreshInterface,
      refresh,
      setTheme,
      setLang,
      setPreference,
      lock,
      unlock,
      web3;
    cweb3 = {};
    refreshTimer = config != null ? config.refreshTimer : void 8;
    use = buildUse(cweb3, store);
    install = buildInstall(cweb3, store);
    installQuick = buildQuickInstall(cweb3, store);
    uninstall = buildUninstall(cweb3, store);
    installByName = buildInstallByName(cweb3, store);
    naming = ethnamed(cweb3);
    getSupportedTokens = buildGetSupportedTokens(cweb3, store);
    getAccountName = buildGetAccountName(cweb3, naming);
    refreshBalances = function (cb) {
      setupRefreshTimer({
        refreshTimer: refreshTimer,
        refreshBalances: refreshBalances,
      });
      return backgroundRefreshAccount(cweb3, store, function (err) {
        return typeof cb == 'function' ? cb(null) : void 8;
      });
    };
    setupRefreshTimer({
      refreshTimer: refreshTimer,
      refreshBalances: refreshBalances,
    });
    init = function (cb) {
      return setAccount(cweb3, store, cb);
    };
    refreshInterface = function (cb) {
      return refreshApis(cweb3, store, function (err) {
        if (err != null) {
          return cb(err);
        }
        return cb(null);
      });
    };
    refresh = function (cb) {
      return refreshInterface(function (err) {
        if (err != null) {
          return cb(err);
        }
        return refreshBalances(cb);
      });
    };
    setTheme = function (it, cb) {
      if (
        it !== 'dark' &&
        it !== 'light' &&
        it !== 'monochrome' &&
        it !== 'dark_mojave'
      ) {
        return cb('support only dark an light');
      }
      store.theme = it;
      setPageTheme(store, it);
      return cb(null);
    };
    setLang = function (it, cb) {
      if (it !== 'en' && it !== 'ru' && it !== 'ua') {
        return cb('support only en, ru');
      }
      store.lang = it;
      return cb(null);
    };
    setPreference = function (preference) {
      var set;
      set = function (key) {
        var ref$;
        return (store.preference[key] =
          (ref$ = preference[key]) != null ? ref$ : store.preference[key]);
      };
      return each(set)(keys(store.preference));
    };
    lock = function () {
      return navigate(store, void 8, 'locked');
    };
    unlock = buildUnlock(store, cweb3);
    refreshInterface(function () {});
    //web3 = new Web3();
    importAll$(cweb3, {
      unlock: unlock,
      setPreference: setPreference,
      getSupportedTokens: getSupportedTokens,
      use: use,
      refresh: refresh,
      lock: lock,
      init: init,
      install: install,
      uninstall: uninstall,
      installByName: installByName,
      naming: naming,
      getAccountName: getAccountName,
      setTheme: setTheme,
      setLang: setLang,
      installQuick: installQuick,
    });
    return cweb3;
  };
  function importAll$(obj, src) {
    for (var key in src) obj[key] = src[key];
    return obj;
  }
  function in$(x, xs) {
    var i = -1,
      l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}.call(this));
