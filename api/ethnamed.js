// Generated by LiveScript 1.6.0
(function () {
  var Ethnamed,
    abi,
    ref$,
    put,
    get,
    post,
    sha3num,
    url,
    getVerifyEmailUrl,
    jsonParse,
    toHex,
    getContractInstance,
    extractSignature,
    getDomain,
    verifyEmail,
    getAccessKey,
    getPaidTransaction,
    getFreeTransaction,
    builderSetupRecord,
    builderWhois,
    builderVerifyRecord,
    builderSendTo,
    toString$ = {}.toString;
  Ethnamed = require('./addresses.json').Ethnamed;
  abi = require('./Ethnamed.abi.json');
  (ref$ = require('../web3t/providers/superagent.js')),
    (put = ref$.put),
    (get = ref$.get),
    (post = ref$.post);
  sha3num = require('solidity-sha3').sha3num;
  url = require('./config.json').url;
  getVerifyEmailUrl = require('./get-verify-email-url.js');
  jsonParse = require('./json-parse.js');
  toHex = function (o) {
    var n;
    if (o == null) {
      return o;
    }
    if (o.toString().indexOf('0x') === 0) {
      return o;
    }
    n = +o;
    return '0x' + n.toString(16);
  };
  getContractInstance = function (web3, abi, addr) {
    switch (false) {
      case toString$.call(web3.eth.contract).slice(8, -1) !== 'Function':
        return web3.eth.contract(abi).at(addr);
      default:
        return new web3.eth.Contract(abi, addr);
    }
  };
  extractSignature = function (signature) {
    var sig, r, s, v;
    sig = signature.slice(2);
    r = '0x' + sig.slice(0, 64);
    s = '0x' + sig.slice(64, 128);
    v = '0x' + sig.slice(128, 130);
    return {
      v: v,
      r: r,
      s: s,
    };
  };
  getDomain = function (name) {
    switch (false) {
      case !(name.indexOf('.') > -1):
        return name;
      default:
        return name + '.web3.space';
    }
  };
  verifyEmail = function (emailkey, cb) {
    var url;
    url = getVerifyEmailUrl(emailkey);
    return get(url).end(function (err, data) {
      if (err != null) {
        return cb(data.text);
      }
      return jsonParse(data.text, cb);
    });
  };
  getAccessKey = function (arg$, cb) {
    var name, record, domain;
    (name = arg$.name), (record = arg$.record);
    if (name == null) {
      return cb('Name is required');
    }
    if (record == null) {
      return cb('Record is required');
    }
    domain = getDomain(name);
    return put(url + '/naming', {
      domain: domain,
      record: record,
    }).end(function (err, data) {
      if (err != null) {
        return cb(data.text);
      }
      return jsonParse(data.text, cb);
    });
  };
  getPaidTransaction = function (
    web3,
    contract,
    gasLimit,
    amount,
    length,
    name,
    record,
    blockExpiry,
    owner,
    v,
    r,
    s
  ) {
    var toWei, ref$, ref1$, data, transaction;
    toWei =
      (ref$ = (ref1$ = web3.utils) != null ? ref1$.toWei : void 8) != null
        ? ref$
        : web3.toWei;
    data = (function () {
      switch (false) {
        case contract.methods == null:
          return contract.methods
            .setOrUpdateRecord(
              length,
              name,
              record,
              blockExpiry,
              owner,
              v,
              r,
              s
            )
            .encodeABI();
        default:
          return contract.setOrUpdateRecord.getData(
            length,
            name,
            record,
            blockExpiry,
            owner,
            v,
            r,
            s
          );
      }
    })();
    return (transaction = {
      to: Ethnamed,
      gas: toHex(gasLimit),
      value: toWei(amount + '', 'ether').toString(),
      data: data,
      decodedData:
        'setOrUpdateRecord("' +
        length +
        '", "' +
        name +
        '", "' +
        record +
        '", "' +
        blockExpiry +
        '", "' +
        owner +
        '", "' +
        v +
        '", "' +
        r +
        '", "' +
        s +
        '")',
    });
  };
  getFreeTransaction = function (
    web3,
    contract,
    gasLimit,
    amount,
    length,
    name,
    record,
    blockExpiry,
    owner,
    v,
    r,
    s
  ) {
    var toWei, ref$, ref1$, data, transaction;
    toWei =
      (ref$ = (ref1$ = web3.utils) != null ? ref1$.toWei : void 8) != null
        ? ref$
        : web3.toWei;
    data = (function () {
      switch (false) {
        case contract.methods == null:
          return contract.methods
            .setOrUpdateRecord2(
              length,
              name,
              record,
              blockExpiry,
              owner,
              v,
              r,
              s
            )
            .encodeABI();
        default:
          return contract.setOrUpdateRecord2.getData(
            length,
            name,
            record,
            blockExpiry,
            owner,
            v,
            r,
            s
          );
      }
    })();
    return (transaction = {
      to: Ethnamed,
      gas: toHex(gasLimit),
      value: 0,
      data: data,
      decodedData:
        'setOrUpdateRecord2("' +
        length +
        '", "' +
        name +
        '", "' +
        record +
        '", "' +
        blockExpiry +
        '", "' +
        owner +
        '", "' +
        v +
        '", "' +
        r +
        '", "' +
        s +
        '")',
    });
  };
  builderSetupRecord = function (web3, contract) {
    return function (arg$, cb) {
      var amountEthers, name, record, owner, toWei, ref$, ref1$;
      (amountEthers = arg$.amountEthers),
        (name = arg$.name),
        (record = arg$.record),
        (owner = arg$.owner);
      toWei =
        (ref$ = (ref1$ = web3.utils) != null ? ref1$.toWei : void 8) != null
          ? ref$
          : web3.toWei;
      return getAccessKey(
        {
          name: name,
          record: record,
        },
        function (err, accessKey) {
          var signature,
            record,
            name,
            length,
            blockExpiry,
            ref$,
            v,
            r,
            s,
            amount;
          if (err != null) {
            return cb(err);
          }
          if (accessKey.result != null) {
            return cb(null, accessKey.result);
          }
          if (owner == null) {
            return cb('Owner address is not defined');
          }
          if (accessKey == null) {
            return cb('Access keys not found');
          }
          (signature = accessKey.signature),
            (record = accessKey.record),
            (name = accessKey.name),
            (length = accessKey.length),
            (blockExpiry = accessKey.blockExpiry);
          (ref$ = extractSignature(signature)),
            (v = ref$.v),
            (r = ref$.r),
            (s = ref$.s);
          amount = (amountEthers != null ? amountEthers : '0').toString();
          return web3.eth.getBlock('latest', function (err, data) {
            var gasLimit, getTransaction, transaction;
            gasLimit = +data.gasLimit - 10;
            getTransaction = (function () {
              switch (false) {
                case amount === '0':
                  return getPaidTransaction;
                default:
                  return getFreeTransaction;
              }
            })();
            transaction = getTransaction(
              web3,
              contract,
              gasLimit,
              amount,
              length,
              name,
              record,
              blockExpiry,
              owner,
              v,
              r,
              s
            );
            return web3.eth.sendTransaction(transaction, cb);
          });
        }
      );
    };
  };
  builderWhois = function (web3, contract) {
    return function (record, cb) {
      var hash;
      hash = sha3num(record);
      if (contract.methods != null) {
        return contract.methods.whois(hash).call(cb);
      }
      return contract.whois(hash, cb);
    };
  };
  builderWhois = function (web3, contract) {
    return function (record, cb) {
      var hash;
      hash = sha3num(record);
      return get(url + '/naming/whois/' + hash).end(function (err, data) {
        if (err != null) {
          return cb(data.text);
        }
        return cb(null, data.text);
      });
    };
  };
  builderVerifyRecord = function (web3, contract) {
    return function (name, cb) {
      if (contract.methods != null) {
        return contract.methods.resolve(getDomain(name)).call(cb);
      }
      return contract.resolve(getDomain(name), cb);
    };
  };
  builderVerifyRecord = function (web3, contract) {
    return function (name, cb) {
      return post(url + '/naming/resolve', {
        name: name,
      }).end(function (err, data) {
        if (err != null) {
          return cb(data.text);
        }
        return cb(null, data.text);
      });
    };
  };
  builderSendTo = function (web3, contract) {
    return function (arg$, cb) {
      var amountEthers, name, toWei, ref$, ref1$, data, transaction;
      (amountEthers = arg$.amountEthers), (name = arg$.name);
      if (amountEthers == null) {
        return cb('Amount ETH is required');
      }
      if (name == null) {
        return cb('Name is required');
      }
      toWei =
        (ref$ = (ref1$ = web3.utils) != null ? ref1$.toWei : void 8) != null
          ? ref$
          : web3.toWei;
      data = (function () {
        switch (false) {
          case contract.methods == null:
            return contract.methods.sendTo(name).encodeABI();
          default:
            return contract.methods.sendTo.getData(name);
        }
      })();
      transaction = {
        to: Ethnamed,
        gas: toHex(5000000),
        value: toWei(amountEthers + '', 'ether').toString(),
        data: data,
        decodedData: 'sendTo("' + name + '")',
      };
      return web3.eth.sendTransaction(transaction, cb);
    };
  };
  module.exports = function (web3) {
    var contract, setupRecord, verifyRecord, whois, sendTo, ref$;
    contract = {};
    setupRecord = builderSetupRecord(web3, contract);
    verifyRecord = builderVerifyRecord(web3, contract);
    whois = builderWhois(web3, contract);
    sendTo = builderSendTo(web3, contract);
    return (
      (ref$ = {}),
      import$(ref$, contract),
      (ref$.setupRecord = setupRecord),
      (ref$.verifyRecord = verifyRecord),
      (ref$.whois = whois),
      (ref$.verifyEmail = verifyEmail),
      (ref$.sendTo = sendTo),
      ref$
    );
  };
  function import$(obj, src) {
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}.call(this));
